# Chapter 2 Application layer

## 2.1 네트워크 어플리케이션 구조

**`클라이언트-서버 아키텍처`** 

- **서버**
    - 항상 켜져있는 호스트
    - 클라이언트라 불리는 여러 다른 호스트의 요청 처리
- 클라이언트 서로 직접 통신 **X** (ex) 웹 애플리케이션의 두 브라우저
- 서버는 고정된  IP 주소를 가짐
- 클라이언트 → 서버의 IP 주소로 패킷 전송 → 서버 접속

**`피어 투 피어(P2P) 아키텍처`**

- 전용 서버에 대한 의존도 거의 적음
    
    → 대신 애플리케이션은 간헐적으로 연결된 호스트 쌍 (피어) 간의 직접 통신 활용
    
    → 트래픽이 많은 애플리케이션 P2P 아키텍처 채택 多
    
- **자가 확장성**
- **비용 효율적**
    - 상당한 서버 인프라 및 서버 대역폭이 필요하지 않기 때문 ( ↔ 데이터 센터를 가진 클라이언트 - 서버와 비교)
- **`but`** 높은 분산 구조로 인해 보안, 성능 및 신뢰성의 문제

### 2.1.2 Processes Communicating

> **not actually programs but processes that communicate**
> 

![image](https://github.com/user-attachments/assets/69902582-5145-4b7f-b9bf-9e7c42aa9f7d)


### **`Process communicating`**

- **process**
    - host 안에서 program 수행
    - **`같은 host`** 내의 두 process : inter-process 통신을 사용하여 통신
    - **`다른 host`**에 있는 process : msg(메세지)를 주고 받음
- **clients & servers process :** P2P 아키텍처 적용
    - **client process** : 통신을 시작하는 프로세스
    - **server process** : 연결되기를 기다리는 프로세스

### **`Sockets`**

- 프로세스와 컴퓨터 네트워크 간의 메세지를 송수신하는 인터페이스
- 호스트 내의 애플리케이션 계층과 전송 계층 간의 인터페이스

### **`Addressing process`**

- 수신 프로세스를 식별하기 위한 정보
    - 호스트의 주소 **(IP 주소)**
    - 대상 호스트에서 수신 프로세스를 지정하는 식별자 (**목적지 포트 번호)**

### 2.1.3 Transport Services Available to Applications

- **`신뢰할 수 있는 데이터 전송`**
    - 프로토콜이 데이터 전달 애플리케이션의 한쪽 끝에서 보낸 데이터가 다른 끝에 정확하고 완전하게 전달되도록 보장하는 것
    - 트랜스포트 프로토콜이 이 서비스를 제공할 때
        - 송신 프로세스 : 데이터를 소켓에 전달하기만 하면
            
            → 데이터가 수신 프로세스에 오류 없이 도착할 것이라고 확신 가능
            
- **`throughput`**
    - 두 프로세스 간의 통신 세션에서 네트워크 경로를 따라 송신 프로세스가 수신 프로세스에게 비트를 전달할 수 있는 속도를 의미
    - 특정 속도로 사용 가능한 처리량을 보장
- **`timing`**
    - 데이터의 도착 시간 보장
- **`security`**
    - 암호화, 데이터 무결성 등의 보안 서비스 제공

### 2.1.4 Transport Services Provided by the Internet

- 인터넷 전송 프로토콜이 제공하는 서비스
- **TCP service**
    - sending/receiving process 사이의 reliable transport
    - flow control : 상대와 패킷 전송 속도 조절
    - congestion control : network 전체가 감당할 수 있는 것보다 많이 들어오면 packet 수 조절
    - connection-oriented : 연결 지향, client/server process간 전송 제어 정보 교환 (setup), ≠ connection service, source&destination만 아니까 process의 setup이 요구됨
    - does not provide : timing, minimum throughput guarantee, security
    
    ### **`Secure Sockets Layer (SSL)`**
    
    - TCP의 보안이 개선된 버전
    - 기존 TCP가 하는 일 + 암호화, 데이터 무결성, 엔드포인트 인증 등의 중요한 프로세스 간 보안 서비스 제공
    - TCP 및 UDP와 같은 전송 계층 X → 애플리케이션 계층에서 구현
    - **과정**
        - 전송 프로세스 : 평문 데이터 → SSL 소켓에 전달 → 데이터를 암호화
        - 암호화된 데이터 : TCP 소켓으로 전달 → 인터넷을 통해 수신 프로세스의 TCP 소켓으로 전달
        - 수신 소켓 : 암호화된 데이터 → SSL이 데이터 복호화 → SSL 소켓을 통해 평문 데이터를 수신 프로세스에 전달
- **UDP service**
    - TCP에 비해 간단
    - unreliable data transfer : 그대로 app에 넘김, 작업 X
    - does no provide : reliability, flow control, congestion control, timing, throughput guarantee, security, connection setup

## 2.2 웹과 HTTP

### 2.2.1 HTTP (HyperText Transfer Protocol)

- 웹의 애플리케이션 계층 프로토콜
- 서로 다른 종단 시스템에서 실행되는 클라이언트와 서버 프로그램 사이에 교환하는 메시지의 구조와 메시지 교환 방식을 정의
- 웹 클라이언트가 웹 서버로부터 웹 페이지를 요청하는 방법과 서버가 웹 페이지를 클라이언트에게 전송하는 방법 정의
- **URL**
    - 객체가 위치한 **서버의 호스트 이름** + **객체의 경로 이름**으로 구성`http://www.someSchool.edu/someDepartment/picture.gif`
- 웹 브라우저
    - (ex Internet Explorer와 Firefox)
    - HTTP의 클라이언트 측을 구현
- 웹 서버
    - HTTP의 서버 측을 구현
    - 각각 URL로 접근 가능한 웹 객체 보관

## 2.2.2 Non-Persistent and Persistent Connections

> **HTTP는 기본 모드에서 영속 연결, HTTP 클라이언트와 서버는 비영속 연결**
> 

### 비영속 연결을 사용하는 HTTP

- 클라이언트-서버 상호작용 시, 각 요청/응답 쌍을 별도의 TCP 연결을 통해 전송
- 서버에서 클라이언트로 웹 페이지를 전송하는 단계
- 페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성되어 있고, 이 11개의 객체가 모두 동일한 서버에 있다고 가정합시다. 또한 기본 HTML 파일의 URL이 `http://www.someSchool.edu/someDepartment/home.index`라고 가정합시다. 다음과 같은 일들이 발생합니다:
1. HTTP 클라이언트 프로세스가 서버 `www.someSchool.edu`의 포트 번호 80(HTTP의 기본 포트 번호)으로 TCP 연결을 시작합니다. TCP 연결과 관련하여, 클라이언트와 서버에는 각각 소켓이 생성됩니다.
2. HTTP 클라이언트가 자신의 소켓을 통해 서버에 HTTP 요청 메시지를 보냅니다. 요청 메시지에는 경로 이름 `/someDepartment/home.index`가 포함되어 있습니다. 
3. HTTP 서버 프로세스가 자신의 소켓을 통해 요청 메시지를 수신하고, 저장소(RAM 또는 디스크)에서 객체 `/someDepartment/home.index`를 검색하여 이를 HTTP 응답 메시지에 캡슐화하여 클라이언트의 소켓을 통해 응답 메시지를 보냅니다.
4. HTTP 서버 프로세스는 TCP에 TCP 연결을 닫도록 지시합니다. (그러나 TCP는 클라이언트가 응답 메시지를 온전히 수신했음을 확신할 때까지 실제로 연결을 종료하지 않습니다.)
5. HTTP 클라이언트는 응답 메시지를 수신합니다. TCP 연결이 종료됩니다. 메시지는 캡슐화된 객체가 HTML 파일임을 나타냅니다. 클라이언트는 응답 메시지에서 파일을 추출하여 HTML 파일을 검사하고 10개의 JPEG 객체에 대한 참조를 발견합니다.
6. 그런 다음 참조된 각 JPEG 객체에 대해 처음 네 단계를 반복합니다.

브라우저가 웹 페이지를 수신하면 이를 사용자에게 표시합니다. 

- 위의 단계는 비영속 연결의 사용을 보여줍니다. 서버가 객체를 전송한 후 각 TCP 연결이 닫힙니다. 연결은 다른 객체에 대해 지속되지 않습니다. 각 TCP 연결은 정확히 하나의 요청 메시지와 하나의 응답 메시지를 전송합니다. 따라서 이 예에서 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결이 생성됩니다.
- 병렬 TCP 연결 사용 → 응답 시간 단축
- 클라이언트가 기본 HTML 파일을 요청한 시점부터 클라이언트가 전체 파일을 받을 때까지 경과하는 시간
    
![image](https://github.com/user-attachments/assets/8e0a731d-3e56-4409-bbcb-204b1d538640)

    
- 클라이언트에서 서버로 작은 패킷이 이동한 후 다시 클라이언트로 돌아오는 데 걸리는 시간을 라운드 트립 타임(RTT)
- RTT에는 패킷 전파 지연, 중간 라우터 및 스위치의 패킷 큐잉 지연, 패킷 처리 지연이 포함
- 그림 2.7에 나와 있듯이, 이는 브라우저와 웹 서버 간에 TCP 연결을 시작하게 합니다. 여기에는 "3단계 핸드셰이크"가 포함됩니다. 클라이언트가 서버로 작은 TCP 세그먼트를 보내고, 서버가 이를 확인하고 작은 TCP 세그먼트로 응답하며, 마지막으로 클라이언트가 서버로 다시 확인합니다. 3단계 핸드셰이크의 처음 두 부분이 1 RTT를 소요합니다. 핸드셰이크의 처음 두 부분을 완료한 후, 클라이언트는 HTTP 요청 메시지를 3단계 핸드셰이크(확인)와 함께 TCP 연결로 보냅니다. 요청 메시지가 서버에 도착하면, 서버는 HTML 파일을 TCP 연결로 보냅니다. 이 HTTP 요청/응답은 추가로 1 RTT를 소요합니다. 따라서 대략적으로 총 응답 시간은 2 RTT와 서버의 HTML 파일 전송 시간을 포함합니다.

### 영속 연결을 사용하는 HTTP

- 비영속 연결의 **단점**
    - 요청된 객체마다 새로운 연결을 설정하고 유지해야 함
        
         → 각 연결에 대해 TCP 버퍼가 할당, 클라이언트와 서버 모두에서 TCP 변수      유지해야 함 → 웹 서버에 상당한 부담
        
    - 각 객체는 2 RTT의 전달 지연을 겪음
        
        (TCP 연결 설정 시간 + 객체를 요청하고 수신하는 데 걸리는 시간)
        
- HTTP 영속 연결
    - 서버가 응답을 보낸 후 TCP 연결을 열어 둠
        
        → **같은 클라이언트와 서버 간의 후속 요청/ 응답은 동일한 연결을 통해 전송 O**
        
    - 전체 웹 페이지(위의 예에서 기본 HTML 파일과 10개의 이미지)는 하나의 영속적인 TCP 연결을 통해 전송될 수 있습니다. 게다가, 동일한 서버에 위치한 여러 웹 페이지를 같은 클라이언트에 전송할 때도 동일한 영속적인 TCP 연결을 사용할 수 있습니다.
    - 이러한 객체 요청은 보류 중인 요청에 대한 응답을 기다리지 않고 연속적으로 이루어질 수 있습니다(파이프라이닝).
    - 일반적으로 HTTP 서버는 일정 시간 동안 사용되지 않으면 연결을 닫음
    - 서버가 연속적인 요청을 수신하면, 객체를 연속적으로 전송합니다. HTTP의 기본 모드는 파이프라이닝이 가능한 영속 연결을 사용

### 2.2.3 HTTP 메시지 형식

### **`HTTP 요청 메시지`**

```yaml
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

> HTTP 요청 메시지의 첫 번째 줄 : **요청 라인**
> 

> 뒤의 줄들 : **헤더 라인**
> 
- **요청 라인**
    - **메소드 필드**, **URL 필드**, **HTTP 버전 필드**
    - `GET`, `POST`, `HEAD`, `PUT`, `DELETE`
    - 대부분의 HTTP 요청 메시지는 `GET` 메소드 사용
    - (예시) 브라우저가 `/somedir/page.html` 객체 요청
- **헤더 라인**
    - `Host: www.someschool.edu`
        - 객체가 존재하는 호스트 지정
        - 웹 프록시 캐시에 필요한 정보
    - `Connection: close`
        - 브라우저는 서버에게 지속적인 연결을 유지하는 것을 원하지 X
        - 요청된 객체를 전송한 후 연결을 종료하도록 요청
    - `User-agent:`
        - 사용자 에이전트, 즉 **서버**에 요청을 보내고 있는 브라우저 유형
        - 서버가 실제로 동일한 객체의 다른 버전을 서로 다른 유형의 사용자 에이전트에게 전송할 수 있기 때문에 유용
    - `Accept-language:`
        - 사용자가 서버에 프랑스어 버전의 객체가 있을 경우 이를 수신하기를 선호
        - 프랑스어 버전의 객체가 없을 경우, 서버는 기본 버전을 전송
        - HTTP에서 사용할 수 있는 여러 콘텐츠 협상 헤더 중 하나
- **요청 메시지의 일반적인 형식**
    
   ![image](https://github.com/user-attachments/assets/eccdcd14-a566-49fb-9fbc-e80c92d58777)

    
    - 헤더 라인 이후 “엔티티 본문”
    - `GET` 메소드에서는 엔티티 본문이 비어 있지만, `POST` 메소드에서는 사용
- `HEAD` 메소드
    - 서버가 요청된 객체를 제외하고 HTTP 메시지를 반환
    - 디버깅에 사용
- `PUT` 메소드
    - 사용자가 특정 웹 서버의 특정 경로(디렉토리)에 객체를 업로드할 수 있도록 함
- `DELETE` 메소드
    - 사용자 또는 응용 프로그램이 웹 서버에서 객체를 삭제할 수 있도록 함

---

### **`HTTP 응답 메시지`**

> **구성 : 상태 라인, 여섯 개의 헤더 라인, 엔티티 본문**
> 

```yaml
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)
```

- **엔티티 본문**
    - 요청된 객체 자체
- **상태 라인**
    - **구성**
        - 프로토콜 버전 필드, 상태 코드, 상태 메시지
- **헤더 라인 (generated by 서버)**
    - `Connection: close`
        - 메시지를 전송한 후 TCP 연결을 닫을 것임을 클라이언트에게 알림
    - `Date:`
        - HTTP 응답이 서버에 의해 생성되고 전송된 시간과 날짜
    - `Server:`
        - 메시지가 어떤 웹 서버에 의해 생성되었음을 나타냄
    - `Last-Modified:`
        - 객체가 생성되거나 마지막으로 수정된 시간과 날짜
        - 로컬 클라이언트와 프록시 서버의 객체 캐싱에 매우 중요
    - `Content-Length:`
        - 전송되는 객체의 바이트 수
    - `Content-Type:`
        - 엔티티 본문에 있는 객체의 유형
- **응답 메시지의 일반적인 형식**
    
   ![image](https://github.com/user-attachments/assets/ceedce9d-33cd-440a-8b9a-81fd1a7bc8ee)

    

**`상태 코드 : 요청 결과`**

- **200 OK**: 요청이 성공했으며 정보가 응답으로 반환
- **301 Moved Permanently**: 요청된 객체가 영구적으로 이동되었으며, 새로운 URL은 응답 메시지의 `Location:` 헤더에 지정, 클라이언트 소프트웨어는 자동으로 새로운 URL을 가져옴
- **400 Bad Request**: 요청을 서버가 이해할 수 없는 일반적인 오류 코드
- **404 Not Found**: 요청된 문서가 이 서버에 존재 X
- **505 HTTP Version Not Supported**: 요청된 HTTP 프로토콜 버전이 서버에서 지원 X

## 2.2.4 사용자-서버 상호작용: 쿠키

- 사용자 접근을 제한하거나 사용자 신원에 따라 콘텐츠를 제공하기 위해
    
    웹 사이트가 사용자를 식별할 수 있는 수단
    

### **`쿠키 기술의 네 가지 구성 요소`**

1. HTTP 응답 메시지의 쿠키 헤더 라인
2. HTTP 요청 메시지의 쿠키 헤더 라인
3. 사용자의 종단 시스템에 저장되고 사용자의 브라우저에 의해 관리되는 쿠키 파일
4. 웹 사이트의 백엔드 데이터베이스
    
    ![image](https://github.com/user-attachments/assets/0828d1ba-60d6-4614-b50b-3e356e41a230)

    

## 2.2.5 웹 캐시(Web cache) (프록시 서버)

- 원본 웹 서버를 대신하여 HTTP 요청을 처리하는 네트워크 엔터티
- 웹 캐시는 자체 디스크 저장소를 가지고 있으며, 최근에 요청된 객체의 복사본을 이 저장소에 보관합니다. 그림 2.11에서 보여주는 것처럼 사용자의 브라우저는 모든 HTTP 요청이 먼저 웹 캐시에 전달되도록 설정될 수 있습니다. 브라우저가 설정되면, 객체에 대한 각 브라우저 요청은 먼저 웹 캐시로 전달됩니다.
- 예를 들어, 브라우저가 객체 `http://www.someschool.edu/campus.gif`를 요청한다고 가정해 봅시다. 여기서 일어나는 과정을 설명하겠습니다:
1. 브라우저는 웹 캐시로 TCP 연결을 설정하고, 객체에 대한 HTTP 요청을 웹 캐시에 보냅니다.
2. 웹 캐시는 객체의 복사본을 로컬에 저장하고 있는지 확인합니다. 만약 복사본이 있다면, 웹 캐시는 HTTP 응답 메시지를 통해 클라이언트 브라우저에 객체를 반환합니다.
3. 웹 캐시에 객체가 없다면, 웹 캐시는 원본 서버(즉, `www.someschool.edu`)로 TCP 연결을 엽니다. 웹 캐시는 그런 다음 캐시에서 서버로의 TCP 연결을 통해 객체에 대한 HTTP 요청을 보냅니다. 이 요청을 수신하면, 원본 서버는 HTTP 응답 내에 객체를 웹 캐시로 보냅니다.
4. 웹 캐시가 객체를 수신하면, 로컬 저장소에 복사본을 저장하고 HTTP 응답 메시지를 통해 클라이언트 브라우저로 객체를 보냅니다 (웹 캐시와 클라이언트 브라우저 간의 기존 TCP 연결을 통해).

**캐시는 동시에 서버와 클라이언트의 역할을 한다**는 점에 유의해야 합니다. 브라우저로부터 요청을 받고 응답을 보낼 때는 서버로서 작동하고, 원본 서버에 요청을 보내고 응답을 받을 때는 클라이언트로서 작동합니다.

웹 캐시는 일반적으로 ISP에 의해 구매되고 설치됩니다. 예를 들어, 대학은 캠퍼스 네트워크에 캐시를 설치하고, 모든 캠퍼스 브라우저가 캐시를 가리키도록 설정할 수 있습니다. 또는 대형 가정용 ISP(예: Comcast)는 네트워크 내에 하나 이상의 캐시를 설치하고, 제공되는 브라우저가 설치된 캐시를 가리키도록 미리 구성할 수 있습니다.

**`웹 캐싱 장점`**

- 웹 캐시는 클라이언트 요청에 대한 응답 시간을 크게 줄일 수 있음
    - 클라이언트와 캐시 사이에 고속 연결이 있는 경우가 많으며, 캐시에 요청된 객체가 있는 경우, 캐시는 클라이언트에 신속하게 객체를 전달할 수 있습니다.
- 웹 캐시는 기관의 인터넷 접속 링크에서의 트래픽을 상당히 줄일 수 있음
- 트래픽을 줄임으로써, 기관(예: 회사나 대학)은 대역폭을 빠르게 업그레이드할 필요가 없어져 비용이 절감됩니다. 더욱이 웹 캐시는 인터넷 전반에서 웹 트래픽을 크게 줄일 수 있어 모든 애플리케이션의 성능을 향상
- 브라우저가 객체를 요청한 시점부터 객체를 받을 때까지의 응답 시간
    - LAN 지연, 접속 지연(두 라우터 간의 지연), 인터넷 지연의 합

이제 접속 링크를 업그레이드하지 않고 대신 기관 네트워크에 웹 캐시를 설치하는 대안적 해결책 → 캐시와 원본 서버로 부하가 나눠짐

## 2.3 Electronic Mail in the Internet

### **E-mail**

- 가장 먼저 개발된 인터넷 application이다
- 3개의 주요 component를 가진다
    - user agent : 브라우저를 이용해 email을 작성/편집/송신/수신
    - mail server
    - SMTP : simple mail transfer protocol : 서버끼리 주고 받기 위해
- user agent
    - = mail reader
    - 작성, 편집, 읽기, 보내기
    - Ex. outlook, iphone mail client
    - 서버에 저장된 메일을 보내거나 받음
- mail server
    - mailbox는 사용자의 수신(들어온) 메세지 유지/소유
    - 송신(보낼) 메세지의 message queue 운영
    - email message를 보내기 위해 SMTP protocol은 mail server 사이에 존재, 주고받는 데에 필요한 프로토콜
        - client : mail server 보내기, 보낼 땐 client로 동작
        - server : mail server 받기, 받을 땐 server로 동작
- RFC (5321)
    - 메일 전송을 위한 문서
    - TCP를 이용해 mail을 relieably하게 보낸다
    - Port 25로
    - direct transfer : 직접 보내고 직접 받는다
    - transfer 절차
        1. handshaking → 상대방과 established 됐다고 표현
        2. transfer of messages
        3. closure
    - command/response 상호 작용
        - command : ASCII text → reliable함, requset msg 대신 사용
        - response : status code and phrase
    - msg는 7bit ASCII 여야 한다 (binary(음성 등)를 ASCII 7bit로 끊어 바꾸어 보냄)

### 2.3.1 SMTP

- HTTP
    - pull, 가져오는 것
    - 각각의 object는 자신의 reponse msg를 암호화한다, 따로따로 포장해온다
- SMTP
    - push, 주는 것
    - 여러개의 object가 multipart message로 보내짐, 하나로 포장하여 같이 옴
    - 지속적인 연결 → 한 번에 연결하여 여러 개를 보낸다
    - 7bit ASCII로 msg(header&body) 요구
    - . 은 msg의 끝을 의미함 (server)
- 둘 다 ASCII command/response interaction과 status codes

### 2.3.2 SMTP vs HTTP

- 두 프로토콜 모두 한 호스트에서 다른 호스트로 파일을 전송하는 데 사용
- **HTTP**
    - 웹 서버에서 웹 클라이언트(일반적으로 브라우저)로 파일을 전송
    - 주로 **풀(pull) 프로토콜**
        
        → 정보(파일)를 받으려는 측이 TCP 연결 시작
        
    - HTTP 데이터는 형식 X
    - 문서를 자신의 HTTP 응답 메시지에 캡슐화
- **SMTP**
    - 한 메일 서버에서 다른 메일 서버로 파일 전송
    - 주로 **푸시(push) 프로토콜 :** 발신 메일 서버가 수신 메일 서버로 파일 푸시
        
        → 송신 측이 TCP 연결 시작
        
    - SMTP는 각 메시지 본문이 7비트 ASCII 형식이어야 함 → 아닐 경우 인코딩
    - 모든 메시지의 객체를 하나의 메시지에 넣음

### 2.3.4 Mail Access Protocols

- mail access = mail을 읽는다
- SMTP : receiver’s server에게 email msg의 전달
- mail access protocol : server에서 검색
    - IMAP : Internet Mail Access Protocol, 서버에 저장된 메세의 검색/삭제/폴더를 제공
- HTTP : SMTP, IMAP 위에 웹 기반 인터페이스를 제공하여 email msg 검색

## 2.4 DNS—The Internet’s Directory Service

- IP 주소는 4바이트로 구성되며 엄격한 계층 구조를 가짐
- 왼쪽에서 오른쪽으로 주소를 스캔하면 호스트가 인터넷 내에서 어디에 위치하는지 (즉, 어떤 네트워크 내에 있는지)에 대한 더 구체적인 정보를 얻을 수 있음

### 2.4.1 Services Provided by DNS

호스트를 식별하는 두 가지 방법

- 호스트 이름
    - 사람들은 기억하기 쉬운 호스트 이름 식별자 선호
- IP 주소
    - 라우터는 고정 길이의 계층적으로 구조화된 IP 주소 선호

**`인터넷 도메인 이름 시스템(DNS)`**

- 호스트 이름 → IP 주소로 변환하는 디렉토리 서비스
- DNS 서버의 계층 구조로 구현된 분산 데이터베이스
- 호스트가 분산 데이터베이스를 쿼리할 수 있게 해주는 애플리케이션 계층 프로토콜
- UDP를 통해 실행되며 포트 53 사용

예를 들어, 사용자의 호스트에서 실행되는 브라우저(HTTP 클라이언트)가 URL www.someschool.edu/index.html을 요청할 때 어떤 일이 발생하는지 살펴보겠습니다. 사용자의 호스트가 웹 서버 www.someschool.edu에 HTTP 요청 메시지를 보낼 수 있으려면 먼저 www.someschool.edu의 IP 주소를 얻어야 합니다. 그 과정은 다음과 같습니다.

1. 같은 사용자 머신에서 DNS 애플리케이션의 클라이언트 측이 실행됩니다.
2. 브라우저는 URL에서 호스트 이름 www.someschool.edu를 추출하여 DNS 애플리케이션의 클라이언트 측에 전달합니다.
3. DNS 클라이언트는 호스트 이름이 포함된 쿼리를 DNS 서버에 보냅니다.
4. DNS 클라이언트는 호스트 이름에 대한 IP 주소가 포함된 응답을 결국 받습니다.
5. 브라우저가 DNS로부터 IP 주소를 받으면 해당 IP 주소의 포트 80에서 HTTP 서버 프로세스와의 TCP 연결을 시작할 수 있습니다.

이 예에서 볼 수 있듯이 DNS는 이를 사용하는 인터넷 애플리케이션에 추가적인 지연을 초래합니다. 다행히도, 아래에서 설명하겠지만, 원하는 IP 주소는 종종 "근처"의 DNS 서버에 캐시되어 있어 DNS 네트워크 트래픽 및 평균 DNS 지연을 줄이는 데 도움이 됩니다.

**`DNS의 추가 기능`**

**호스트 별칭(호스트 알리아싱)**

- 복잡한 호스트 이름을 가진 호스트는 하나 이상의 별칭을 가질 수 있음
- DNS는 애플리케이션이 제공된 별칭 호스트 이름에 대한 정규 호스트 이름과 호스트의 IP 주소를 얻기 위해 호출될 수 있음

**메일 서버 별칭(메일 서버 알리아싱)**

- DNS는 메일 애플리케이션이 제공된 별칭 호스트 이름에 대한 정규 호스트 이름과 호스트의 IP 주소를 얻기 위해 호출될 수 있음

**부하 분산(로드 디스트리뷰션)**

- DNS는 복제된 서버간의 부하 분산을 수행하는 데 사용
- CNN과 같은 바쁜 사이트는 여러 서버에 걸쳐 복제되어 있으며, 각 서버는 서로 다른 최종 시스템에서 실행되고 서로 다른 IP 주소를 가지고 있습니다. 복제된 웹 서버의 경우, 하나의 정규 호스트 이름에 여러 IP 주소 집합이 연결됩니다. DNS 데이터베이스는 이 IP 주소 집합을 포함하고 있습니다. 클라이언트가 이름에 매핑된 주소 집합에 대한 DNS 쿼리를 할 때, 서버는 응답에 전체 IP 주소 집합을 제공하지만, 각 응답의 주소 순서를 회전시킵니다. 클라이언트는 일반적으로 집합에서 처음 나열된 IP 주소에 HTTP 요청 메시지를 보내므로, DNS 회전을 통해 복제된 서버 간의 트래픽이 분산됩니다. DNS 회전은 여러 메일 서버가 동일한 별칭 이름을 가질 수 있도록 하기 위해서도 사용됩니다.

### 2.4.2 Overview of How DNS Works

호스트 이름 → IP 주소로 변환하는 서비스에 중점

사용자 호스트에서 실행되는 웹 브라우저나 메일 리더와 같은 애플리케이션이 호스트 이름을 IP 주소로 변환해야 한다고 가정해봅시다. 애플리케이션은 변환이 필요한 호스트 이름을 지정하여 DNS의 클라이언트 측을 호출합니다. (많은 UNIX 기반 시스템에서는 `gethostbyname()` 함수 호출을 통해 변환을 수행합니다.) 사용자의 호스트에 있는 DNS는 네트워크로 쿼리 메시지를 전송하여 이를 처리합니다. 모든 DNS 쿼리 및 응답 메시지는 UDP 데이터그램으로 포트 53으로 전송됩니다. 밀리초에서 몇 초까지 지연된 후, 사용자의 호스트에 있는 DNS는 원하는 매핑을 제공하는 DNS 응답 메시지를 받습니다. 이 매핑은 호출한 애플리케이션에 전달됩니다. 따라서 사용자의 호스트에 있는 호출 애플리케이션의 관점에서 보면, DNS는 간단하고 직관적인 변환 서비스를 제공하는 블랙박스입니다. 그러나 실제로 이 서비스를 구현하는 블랙박스는 복잡하며, 전 세계에 분산된 다수의 DNS 서버와 DNS 서버와 쿼리 호스트가 통신하는 방법을 지정하는 애플리케이션 계층 프로토콜로 구성됩니다.

DNS에 대한 간단한 설계는 모든 매핑을 포함하는 하나의 DNS 서버를 가지는 것입니다. 이 중앙 집중식 설계에서는 클라이언트가 모든 쿼리를 단일 DNS 서버로 전송하고 DNS 서버는 쿼리하는 클라이언트에게 직접 응답합니다. 이 설계의 단순함은 매력적이지만, 오늘날의 인터넷에는 부적절합니다. 인터넷은 방대한 (그리고 성장하는) 수의 호스트를 가지고 있습니다. 중앙 집중식 설계의 문제는 다음과 같습니다.

- **단일 장애 지점**: DNS 서버가 고장 나면 인터넷 전체가 중단됩니다!
- **트래픽 볼륨**: 하나의 DNS 서버는 수억 개의 호스트에서 생성된 모든 HTTP 요청과 이메일 메시지에 대한 모든 DNS 쿼리를 처리해야 합니다.
- **중앙집중화된 데이터베이스 거리**: 하나의 DNS 서버가 쿼리하는 모든 클라이언트에게 "가까이" 있을 수 없습니다. 만약 우리가 뉴욕시에 단일 DNS 서버를 둔다면, 호주의 모든 쿼리는 지구 반대편으로 이동해야 하며, 이는 느리고 혼잡한 링크를 통해야 할 수도 있습니다. 이는 상당한 지연을 초래할 수 있습니다.
- **유지보수**: 단일 DNS 서버는 모든 인터넷 호스트에 대한 기록을 유지해야 합니다. 이 중앙 집중식 데이터베이스는 엄청나게 클 뿐만 아니라, 모든 새로운 호스트를 처리하기 위해 자주 업데이트되어야 합니다.

요약하면, 단일 DNS 서버에 중앙 집중식 데이터베이스를 두는 것은 확장되지 않습니다. 따라서 DNS는 설계상 분산되어 있습니다. 실제로, DNS는 인터넷에서 분산 데이터베이스가 구현될 수 있는 훌륭한 예입니다.

### 분산형 계층 데이터베이스

### DNS 캐싱

### DNS 메시지

### DNS 데이터베이스에 레코드 삽입

### 보안에 집중: DNS 취약점

## 2.5 Peer-to-Peer File Distribution

## 2.6 Video Streaming and Content Distribution Networks

## 2.7 Socket Programming: Creating Network Applications
