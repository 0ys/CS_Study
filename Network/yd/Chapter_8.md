# 8.2 암호의 원리

$$
원래~형태의~메시지:~평문(plaintext)~또는~원문(cleartext)\\
↓\\
암호문(ciphertext)
$$

- 인터넷에서 사용되는 기술을 포함한 현대의 많은 암호화 기술 자체는 모든 이에게 알려져 있다.
- 또한 표준화(ex) RFC1321, RFC 3447, RFC 2420, NIST 2001)되어 누구나 쉽게 사용할 수 있다.
- 암호화하는 방법은 모두가 알고 있더라도 전송한 데이터를 칩입자가 복원할 수 없게 해주는 비밀 정보는 바로 “**Key**”이다.

| 대칭키 시스템(symmetric key system) | 공개키 시스템(public key system) |
| --- | --- |
| 암호화와 복호화에 쓰이는 키가 동일 | 암호화와 복호화에 쓰이는 키가 다름 |

## 8.2.1 대칭키 암호화

- **카이사르 암호(Caesar cipher)**
    - 평문의 각 철자를 알파벳 순서로 k번째 뒤에 오는 철자로 대치한다.
    - ex) K=3
    a → d, b → e 로 대치
    - 금방 해독하기 쉬움
- **단일 문자 대응 암호(monoalphabetic cipher)**
    - 카이사르 암호를 개선
    - 각 철자들은 고유한 대응 글자로 변환된다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/bcae6a3a-d3f8-457f-b546-084947de2c55/518998de-e49d-4695-b308-e5b15613f137/image.png)
        
    - 하지만 이 또한 평문에 대한 통계 분석을 통해 일반 영어 문장에서 가장 흔하게 나타나는 알파벳과 (in, it, the, ion, ing)라는 규칙성을 알고 있으므로 암호문을 해독하는 것이 그리 어렵지 않다.
- **다중 문자 대응 암호화(polyalphabetic encryption)**
    - 단일 문자 대응 암호법을 개선
    - 여러 개의 단일 문자 대응법을 가지고 평문 메시지에서의 위치에 따라 서로 다른 단일 문자 대응 암호법을 사용하는 것
    - ex) K=5 : C1,   K=9 : C2   →   C1, C2, C2, C1, C2를 반복
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/bcae6a3a-d3f8-457f-b546-084947de2c55/4522ce18-9055-419c-b34a-a3f468dcc371/image.png)
        
    
    ### 공격
    
- 암호문만을 이용한 공격
    - 앞서 살펴본 것처럼 통계 분석 사용
- 알려진 평문 공격
    - 암호문 메시지에 나타날 것이라고 확신한 문자열이 있다면, 해당 문자를 포함하는 평문과 암호문의 쌍을 대략 결정할 수 있다.
- 선택 평문 공격
    - 침입자가 특정 평문 메시지를 선택하여 이에 대응하는 암호문 형태를 얻을 수 있다.
    - 임의의 메시지를 보내도록 할 수 있을 때 사용 가능하다.
    - 다만 좀 더 발전된 암호화 기법들에서는 선택 평문 공격이 항상 유효하지는 않다.
    
    ### 블록 암호화
    
- 메시지가 k비트의 블록 단위로 암호화 된다.
- ex) k=64라면 메시지를 64비트의 블록들로 쪼개어 각 블록을 독립적으로 암호화

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/bcae6a3a-d3f8-457f-b546-084947de2c55/72df4363-ea06-4276-970e-7757a9aa2033/image.png)

- 입력 가능한 모든 블록에 대응하는 출력 블록을 가진 테이블 기반 블록 암호화가 매우 안전한 대칭키 암호화 방법이지만, 구현이 어렵다.
- 또한 어떠한 특정 사상이 주어지면, 둘은 테이블을 유지해야 하는데 이는 실행이 거의 불가능하다.
- 대신 블록 암호화 기법은 입출력 블록의 순열 테이블을 임의로 모방 생성하는 함수를 사용한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/bcae6a3a-d3f8-457f-b546-084947de2c55/81917783-8eac-4b9c-9f6d-25adb7b6be16/image.png)

- 오늘날 널리 사용되는 블록 암호화 기법
    - DES, AES
    
    ### 암호 블록 체이닝
    
- 2개 이상의 블록 내 평문의 내용이 ‘HTTP/1.1’로 동일할 수 있음
- 이런 평문에 대해 블록 암호화 기법은 같은 암호문을 생성
- 이러한 문제 해결을 위해 평문 블록이 동일하더라도 다른 암호문 블록이 생성될 수 있도록 기존 암호화 기술에 임의성을 추가할 수 있다.
    - 송신자는 i번째 블록을 위해 k비트 길이의 임의의 수 r(i) 생성
    - c(i) = Ks(m(i) ⊕ r(i))
    - m(i) = Ks(c(i)) ⊕ r(i)
    - r(i)가 암호화되지 않은 채 전달되고 공격자가 감청할 수 있을지라도 키(S)를 알지 못하므로 m(i)를 복원할 수는 없다.
- **첫번째 메시지와 함께 임의의 수를 단 한 번만 전송하고 이후의 임의의 수로는 직전에 계산된 암호문 블록을 대신 사용한다.**

## 8.2.2 공개키 암호화

- 앨리스와 밥이 통신한다고 가정
- 밥(수신자)은 2개의 키를 가짐. 하나는 공개키, 나머지는 개인키
- 개인키를 밥만이 안다.
- 앨리스는 모든 사람에게 알려진 밥의 공개키를 가지고 메시지를 암호화해 전송한다.
- 그러나 공개키 암호화의 경우에는 누구라도 밥에게 밥의 공개키를 사용하여 암호화된 메시지를 전송할 수 있으므로, 어떤 사람이 보낸 메시지인지 알 수 없다.
- 따라서 송신자와 메시지를 연계하기 위해서는 디지털 서명이 필요하다.
- **이러한 문제에 대한 해결법 중 하나가 RSA 알고리즘**
